/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jun 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _INVENTORY_SYNC_HPP
#define _INVENTORY_SYNC_HPP

#include "../policyManager/policyManager.hpp"
#include "chainOfResponsability.hpp"
#include "rocksDBWrapper.hpp"
#include "scanContext.hpp"
#include "timeHelper.h"

constexpr auto OS = "os";
constexpr auto PACKAGE = "package";
constexpr auto OS_INITIAL_SCAN = "os_initial_scan";
const std::map<AffectedComponentType, std::string> AFFECTED_COMPONENT_COLUMNS = {
    {AffectedComponentType::Os, OS}, {AffectedComponentType::Package, PACKAGE}};

/**
 * @brief TInventorySync class.
 * This class is in charge of synchronizing the inventory database.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext>
class TInventorySync
{
protected:
    Utils::RocksDBWrapper& m_inventoryDatabase; ///< Inventory database.

    /**
     * @brief Elements to process.
     * @param operation Operation.
     * @param elementKey Element key.
     * @return nlohmann::json Element to process.
     */
    static nlohmann::json buildElement(const std::string& operation, const std::string& elementKey)
    {
        nlohmann::json json;
        json["operation"] = operation;
        json["id"] = elementKey;
        return json;
    } // LCOV_EXCL_LINE

    /**
     * @brief Builds the affected component key for the inventory database.
     *
     * @param data Scan context.
     * @param out Output string to append the affected component key.
     */
    void appendAffectedComponentKey(const std::shared_ptr<TScanContext>& data, std::string& out) const
    {

        if (!data)
        {
            throw std::runtime_error("Invalid scan context data for inventory key.");
        }

        using Type = AffectedComponentType;

        // Append the "_" separator
        out += "_";

        switch (data->affectedComponentType())
        {
            case Type::Os:
                out.reserve(out.size() + data->osName().size() + 1 + data->osVersion().size());
                out += data->osName();
                out += '_';
                out += data->osVersion();
                break;

            case Type::Package: out += data->packageItemId(); break;

            case Type::Hotfix: out += data->hotfixId(); break;

            default: throw std::runtime_error("Invalid affected component type for inventory key.");
        }
    }

    /**
     * @brief Get the affected component key.
     *
     * @param data Scan context.
     * @return std::string_view Affected component key.
     */
    std::string_view affectedComponentKey(const std::shared_ptr<TScanContext>& data) const
    {
        if (data->affectedComponentType() == AffectedComponentType::Os)
        {
            return data->osName();
        }
        else if (data->affectedComponentType() == AffectedComponentType::Package)
        {
            return data->packageItemId();
        }
        else if (data->affectedComponentType() == AffectedComponentType::Hotfix)
        {
            return data->hotfixId();
        }
        else
        {
            throw std::runtime_error("Invalid affected type for inventory sync.");
        }
    } // LCOV_EXCL_LINE

public:
    // LCOV_EXCL_START
    /**
     * @brief InventorySync constructor.
     *
     * @param inventoryDatabase Inventory database.
     */
    explicit TInventorySync(Utils::RocksDBWrapper& inventoryDatabase)
        : m_inventoryDatabase(inventoryDatabase)
    {
        for (const auto& [componentType, columnName] : AFFECTED_COMPONENT_COLUMNS)
        {
            if (!m_inventoryDatabase.columnExists(columnName))
            {
                m_inventoryDatabase.createColumn(columnName);
            }
        }

        if (!m_inventoryDatabase.columnExists(OS_INITIAL_SCAN))
        {
            m_inventoryDatabase.createColumn(OS_INITIAL_SCAN);
        }
    }

    /**
     * @brief This method updates the element ID by appending a suffix.
     *
     * @param element Element to update.
     * @param suffix Suffix to append to the element ID.
     */
    static void updateElementID(nlohmann::json& element, std::string_view suffix)
    {
        element["id"] = element["id"].get<std::string>().append("_").append(suffix.data(), suffix.size());
    }
    // LCOV_EXCL_STOP
};

using InventorySync = TInventorySync<TScanContext<>>;

#endif // _INVENTORY_SYNC_HPP
